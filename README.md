local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local Window = Rayfield:CreateWindow({
    Name = "BoxBuh",
    Icon = 0, -- Icon in Topbar. Can use Lucide Icons (string) or Roblox Image (number). 0 to use no icon (default).
    LoadingTitle = "Carregando",
    LoadingSubtitle = "By MTS13GAMER",
    Theme = "Default", -- Check https://docs.sirius.menu/rayfield/configuration/themes
 
    DisableRayfieldPrompts = false,
    DisableBuildWarnings = false, -- Prevents Rayfield from warning when the script has a version mismatch with the interface
 
    ConfigurationSaving = {
       Enabled = true,
       FolderName = nil, -- Create a custom folder for your hub/game
       FileName = "BoxBuh"
    },
 
    Discord = {
       Enabled = false, -- Prompt the user to join your Discord server if their executor supports it
       Invite = "BZwtCDS4Vz", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ ABCD would be ABCD
       RememberJoins = true -- Set this to false to make them join the discord every time they load it up
    },
 
    KeySystem = true, -- Set this to true to use our key system
    KeySettings = {
       Title = "System",
       Subtitle = "Key System",
       Note = "No method of obtaining the key is provided", -- Use this to tell the user how to get a key
       FileName = "Key", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
       SaveKey = true, -- The user's key will be saved, but if you change the key, they will be unable to use your script
       GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
       Key = {"mts","freebox","gamer"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
    }
 })

 local Tab = Window:CreateTab("Inicio", 4483362458) -- Title, Image

 local Section = Tab:CreateSection("Inicio")
 
 local Tab3 = Window:CreateTab("Espadachi Renacimento", 4483362458) -- Title, Image

 local Section = Tab3:CreateSection("Espadachi Renacimento")

 local Tab2 = Window:CreateTab("Universal", 4483362458) -- Title, Image

 local Section = Tab2:CreateSection("Universal")


 local Input = Tab2:CreateInput({
   Name = "Altere A Sua Velocidade",
   CurrentValue = "",
   PlaceholderText = "Aqui",
   RemoveTextAfterFocusLost = false,
   Flag = "Input1",
   Callback = function(Text)
      local velocidade = tonumber(Text)
      if velocidade and velocidade >= 0 and velocidade <= 900 then
         print("Velocidade válida: " .. velocidade)
         ConfigurarVelocidade(velocidade)
      else
         print("Por favor, insira um valor de velocidade entre 0 e 900.")
      end
   end,
})

function ConfigurarVelocidade(valor)
   local player = game.Players.LocalPlayer
   if player and player.Character and player.Character:FindFirstChild("Humanoid") then
      player.Character.Humanoid.WalkSpeed = valor
      print("A velocidade do player foi configurada para: " .. valor)
   else
      print("Não foi possível encontrar o jogador ou o Humanoid.")
   end
end

local running = false

-- Script generated by SimpleSpy - credits to exx#9394

-- Toggle "Click Auto"
local running = false

local Toggle = Tab3:CreateToggle({
    Name = "Click Auto",
    CurrentValue = false,
    Flag = "Toggle1", -- A flag é o identificador para o arquivo de configuração, certifique-se de que cada elemento tenha uma flag diferente se você estiver usando salvamento de configuração para garantir que não haja sobreposições
    Callback = function(Value)
        running = Value
        while running do
            game:GetService("ReplicatedStorage").Events.Game.Re_TrainPower:FireServer()
            wait(1) -- Intervalo de 1 segundo entre as ativações
        end
    end,
})

-- Toggle "Auto Spin"
local args = {
    [1] = false
}

local Toggle2 = Tab3:CreateToggle({
    Name = "Auto Spin",
    CurrentValue = false,
    Flag = "Toggle2", -- A flag é o identificador para o arquivo de configuração, certifique-se de que cada elemento tenha uma flag diferente se você estiver usando salvamento de configuração para garantir que não haja sobreposições
    Callback = function(Value)
        running = Value
        while running do
            game:GetService("ReplicatedStorage").Events.Wheel.Rf_UGCSpin:InvokeServer(unpack(args))
            wait(1) -- Intervalo de 1 segundo entre as ativações
        end
    end,
})

local Button = Tab:CreateButton({
   Name = "Destroir Gui",
   Callback = function()
     Rayfield:Destroy()
   end,
})

local Button = Tab2:CreateButton({
    Name = "Reverse (Mobile)",
    Callback = function()
        local flashbacklength = 60 -- duração do flashback em segundos
        local flashbackspeed = 1 -- quantos frames pular durante o flashback (0 para desativar)
         
        local name = game:GetService("RbxAnalyticsService"):GetSessionId() -- ID único
        local frames, LP, RS, UIS = {}, game:GetService("Players").LocalPlayer, game:GetService("RunService"), game:GetService("UserInputService")
         
        pcall(RS.UnbindFromRenderStep, RS, name) -- Desvincula a função se já estiver vinculada
        
        local function getchar()
            return LP.Character or LP.CharacterAdded:Wait()
        end
        
        function gethrp(c)
            return c:FindFirstChild("HumanoidRootPart") or c.RootPart or c.PrimaryPart or c:FindFirstChild("Torso") or c:FindFirstChild("UpperTorso") or c:FindFirstChildWhichIsA("BasePart")
        end
        
        local flashback = {lastinput=false, canrevert=true, isReverting=false}
        
        function flashback:Advance(char, hrp, hum, allowinput)
            if #frames > flashbacklength * 60 then
                table.remove(frames, 1)
            end
            if allowinput and not self.canrevert then
                self.canrevert = true
            end
            if self.lastinput then
                hum.PlatformStand = false
                self.lastinput = false
            end
            table.insert(frames, {
                hrp.CFrame,
                hrp.Velocity,
                hum:GetState(),
                hum.PlatformStand,
                char:FindFirstChildOfClass("Tool")
            })
        end
        
        function flashback:Revert(char, hrp, hum)
            local num = #frames
            if num == 0 or not self.canrevert then
                self.canrevert = false
                self:Advance(char, hrp, hum)
                return
            end
            for i = 1, flashbackspeed do
                table.remove(frames, num)
                num = num - 1
            end
            self.lastinput = true
            local lastframe = frames[num]
            table.remove(frames, num)
            hrp.CFrame = lastframe[1]
            hrp.Velocity = -lastframe[2]
            hum:ChangeState(lastframe[3])
            hum.PlatformStand = lastframe[4]
            local currenttool = char:FindFirstChildOfClass("Tool")
            if lastframe[5] then
                if not currenttool then
                    hum:EquipTool(lastframe[5])
                end
            else
                hum:UnequipTools()
            end
        end
        
        -- Criar botão para mobile e PC
        local screenGui = Instance.new("ScreenGui", LP:WaitForChild("PlayerGui"))
        local reverseButton = Instance.new("TextButton", screenGui)
        reverseButton.Size = UDim2.new(0.1, 0, 0.05, 0) -- Tamanho menor
        reverseButton.Position = UDim2.new(0.8, 0, 0.85, 0)
        reverseButton.Text = "Reverse"
        reverseButton.BackgroundColor3 = Color3.new(1, 0, 0)
        reverseButton.TextScaled = true
        reverseButton.Draggable = true -- Tornar o botão movível
        reverseButton.Active = true
        reverseButton.Selectable = true
        
        local function step()
            local char = getchar()
            local hrp = gethrp(char)
            local hum = char:FindFirstChildWhichIsA("Humanoid")
            if flashback.isReverting then
                flashback:Revert(char, hrp, hum)
            else
                flashback:Advance(char, hrp, hum, true)
            end
        end
        
        reverseButton.MouseButton1Click:Connect(function()
            flashback.isReverting = not flashback.isReverting -- Alternar entre ativar/desativar o flashback
            reverseButton.BackgroundColor3 = flashback.isReverting and Color3.new(0, 1, 0) or Color3.new(1, 0, 0)
        end)
        
        RS:BindToRenderStep(name, 1, step)
        
    end,
 })

local Button = Tab2:CreateButton({
    Name = "Reverse (PC)",
    Callback = function()
        local key = "E" --key to intiate the flashback. see https://create.roblox.com/docs/reference/engine/enums/KeyCode for an exhaustive list
        local flashbacklength = 60 --how long the flashback should be stored in approx seconds
        local flashbackspeed = 1 --how many frames to skip during flashback (set to 0 to disable)
         
        local name = game:GetService("RbxAnalyticsService"):GetSessionId() --unique id that games cannot access but does not change on subsequent executions (used for the name of the binded function)
        local frames,uis,LP,RS = {},game:GetService("UserInputService"),game:GetService("Players").LocalPlayer,game:GetService("RunService") --set some vars
         
        pcall(RS.UnbindFromRenderStep,RS,name) --unbind the function if previously binded
         
        local function getchar()
           return LP.Character or LP.CharacterAdded:Wait()
        end
         
        function gethrp(c) --gethrp ripped from my env script and stripped of arguments
        return c:FindFirstChild("HumanoidRootPart") or c.RootPart or c.PrimaryPart or c:FindFirstChild("Torso") or c:FindFirstChild("UpperTorso") or c:FindFirstChildWhichIsA("BasePart")
        end
         
        local flashback = {lastinput=false,canrevert=true}
         
        function flashback:Advance(char,hrp,hum,allowinput)
         
           if #frames>flashbacklength*60 then --make sure we don't have too much history
               table.remove(frames,1)
           end
         
           if allowinput and not self.canrevert then
               self.canrevert = true
           end
         
           if self.lastinput then --make sure platformstand goes back to normal
               hum.PlatformStand = false
               self.lastinput = false
           end
         
           table.insert(frames,{
               hrp.CFrame,
               hrp.Velocity,
               hum:GetState(),
               hum.PlatformStand,
               char:FindFirstChildOfClass("Tool")
           })
        end
         
        function flashback:Revert(char,hrp,hum)
           local num = #frames
           if num==0 or not self.canrevert then --add to history and return if no history is present
               self.canrevert = false
               self:Advance(char,hrp,hum)
               return
           end
           for i=1,flashbackspeed do --skip frames (if enabled)
               table.remove(frames,num)
               num=num-1
           end
           self.lastinput = true
           local lastframe = frames[num]
           table.remove(frames,num)
           hrp.CFrame = lastframe[1]
           hrp.Velocity = -lastframe[2]
           hum:ChangeState(lastframe[3])
           hum.PlatformStand = lastframe[4] --platformstand to make flying look normal again
           local currenttool = char:FindFirstChildOfClass("Tool")
           if lastframe[5] then --equip/unequip tools
               if not currenttool then
                   hum:EquipTool(lastframe[5])
               end
           else
               hum:UnequipTools()
           end
        end
         
        local function step() --function that runs every frame
           local char = getchar()
           local hrp = gethrp(char)
           local hum = char:FindFirstChildWhichIsA("Humanoid")
           if uis:IsKeyDown(Enum.KeyCode[key]) then --begin flashback
               flashback:Revert(char,hrp,hum)
           else
               flashback:Advance(char,hrp,hum,true)
           end
        end
        RS:BindToRenderStep(name,1,step) --finally, bind our function
    end,
 })

 Rayfield:LoadConfiguration()
